"""
REMARK: the current file is automatically generated by PYV /pyved-engine.
*DO NOT EDIT THAT FILE* (unless you really know what you're doing)
"launch_game.py" is part of the game engine layout. It's the standard
launcher script tied to the "pyved-engine game bundle" format.
The following code helps in booting up a wrapped game cartridge
(->PyvGAMCART format) | To know more, please visit:
https://github.com/pyved-solution | Contact author: thomas.iw@kata.games
"""
import importlib.util
import json
import os
import time


bundle_name, link_to_glvars, pyved_engine_alias = None, None, 'pyved_engine'


def prep_libs(cb_func, rel_import_flag, plugins_list):
    global pyved_engine_alias
    for alias, plugin_name in plugins_list:
        if plugin_name == 'pyved_engine':
            import pyved_engine
            plugin_module = pyved_engine.get_engine_router()
            pyved_engine_alias = alias
            getattr(pyved_engine, 'hub').bundle_name = bundle_name
        elif rel_import_flag:
            module_name = f".lib.{plugin_name}"
            plugin_module = importlib.import_module(module_name, __package__)
        else:
            module_name = f"lib.{plugin_name}"
            plugin_module = importlib.import_module(module_name)
        cb_func(alias, plugin_name, plugin_module)


def game_execution(metadata, gdef_module, **kwargs):
    global link_to_glvars, pyved_engine_alias

    def find_folder(givenfolder, start_path):
        for root, dirs, files in os.walk(start_path):
            if givenfolder in dirs:
                return True

    current_folder = os.getcwd()
    if find_folder(metadata['slug'], current_folder):
        adhoc_folder = os.path.join('.', metadata['slug'], 'cartridge')
    elif find_folder('cartridge', current_folder):
        adhoc_folder = os.path.join('.', 'cartridge')
    else:
        raise FileNotFoundError("ERR: Asset dir for pre-loading assets cannot be found!")
    pyv = getattr(link_to_glvars, pyved_engine_alias)
    
    pyv.bootstrap_e()
    pyv.preload_assets(
        metadata,
        prefix_asset_folder=adhoc_folder + os.sep + metadata['asset_base_folder'] + os.sep,
        prefix_sound_folder=adhoc_folder + os.sep + metadata['sound_base_folder'] + os.sep,
    )
    #for anchor_nam, std_name in {  # standardized mapping
    #    'beginfunc_ref': 'init', 'updatefunc_ref': 'update', 'endfunc_ref': 'close'
    #} .items():
    #    setattr(pyv.vars, anchor_nam, getattr(gdef_module, std_name))
    pyv.run_game(
        getattr(gdef_module, 'init'),
        getattr(gdef_module, 'update'),
        getattr(gdef_module, 'close'),
        **kwargs
    )


def boot_game(mdata_path, **kwargs):
    global bundle_name, link_to_glvars

    with open(mdata_path, 'r') as fp:
        metadata = json.load(fp)

        try:
            from cartridge import glvars as c_glvars
            rel_imports = False
        except ModuleNotFoundError:
            from .cartridge import glvars as c_glvars
            rel_imports = True
        link_to_glvars = c_glvars  # glvars becomes available elsewhere
        lib_list = list()
        for lib_id in metadata['dependencies'].keys():
            if len(metadata['dependencies'][lib_id]) > 1:
                alias = metadata['dependencies'][lib_id][1]
                lib_list.append((alias, lib_id))
            else:
                lib_list.append((lib_id, lib_id))
        bundle_name = metadata['slug']
        prep_libs(c_glvars.register_lib, rel_imports, lib_list)
        if c_glvars.has_registered('network'):  # manually fix the network lib (retro-compat)
            getattr(c_glvars, c_glvars.get_alias('network')).slugname = metadata['slug']
        if not rel_imports:
            from cartridge import gamedef
        else:
            from .cartridge import gamedef
        game_execution(metadata, gamedef, **kwargs)


def server_execution(**kwargs):
    print("Starting server...")
    from servercode import glvars
    print(glvars.pyv)
    # Insert your server initialization and main loop logic here.
    # For example, setting up network connections, initializing services, etc.

    # handy linking.
    # But could it work with trascrypt'pragmas'?
    # from netw_socket_serv import *
    # precursor = {
    #     'get_server_flag': get_server_flag,     # server-side, its like a constant but ok we need it
    #     'start_comms': start_comms,             # called in the server's body -->ok can stay pure JS
    #     'broadcast': broadcast,                 # called by UMediator only. Line 76
    #     'register_mediator': register_mediator  # called only by UMediator line 15, so mediator can receive post call in return
    # }
    # class Objectifier:
    #     def __init__(self, **entries):
    #         self.__dict__.update(entries)
    # netw_layer = Objectifier(**precursor)
    # --- end handy linking ---
    engine_elem = glvars.pyv.neotech

    netw_layer = engine_elem.Objectifier(**engine_elem.build_net_layer('socket', 'server'))
    glvars.mediator = mediator = engine_elem.UMediator()
    mediator.set_network_layer(netw_layer)

    # je crois qu'il faut attendre de s'etre register sur netlayer avant de start comms
    # sinon liste des mediators est vide
    netw_layer.start_comms(kwargs['host'], kwargs['port'])

    from servercode.Server import Server
    serv_obj = Server(**kwargs)

    ff = 1
    cpt = 100
    while True:
        serv_obj.proc_server_logic(time.time())
        glvars.mediator.update(True)  # saving cycles will send updates less frequently which can avoir sync errors
        # on socket interface, but creates a bit of lag
        cpt -= 1
        if cpt <= 0:
            ff = ff ^ 1  # flip bit
            print('  .tick. ' if ff else ' .tac. ')
            cpt = 100
        time.sleep(0.1)


if __name__ == '__main__':  # in case of a "pyv-cli less" execution
    boot_game('cartridge/metadat.json')
